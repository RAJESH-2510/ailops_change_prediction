import sys
from pathlib import Path
from typing import Dict, Any, List, Optional

import pandas as pd
import joblib
from prefect import flow, task, get_run_logger

# Add parent directory to path for imports
sys.path.append(str(Path(__file__).resolve().parent.parent))

# Paths to models
MODEL_DIR = Path(__file__).resolve().parent.parent / 'models'
RF_MODEL_PATH = MODEL_DIR / 'rf_model.joblib'
SCALER_PATH = MODEL_DIR / 'scaler.joblib'

from src.pipeline import AIOpsPipeline
from src.features import FeatureEngineering
from src.ml_models import RealTimeInference
from src.dashboard import AIOpsDashboard
from src.cicd import CICDIntegration

# ROI Calculator
class ROICalculator:
    def __init__(self, infrastructure_cost: float = 5000):
        self.costs = {
            'average_incident_cost': 25000,
            'engineer_hourly_rate': 150,
            'downtime_cost_per_hour': 100000
        }
        self.infrastructure_cost = infrastructure_cost

    @task(log_prints=True)
    def calculate_savings(
        self,
        baseline_cfr: float,
        current_cfr: float,
        deployments_per_month: int,
        actual_prevented_failures: Optional[float] = None
    ) -> Dict[str, float]:
        if actual_prevented_failures is not None:
            prevented_failures = actual_prevented_failures
        else:
            prevented_failures = deployments_per_month * (baseline_cfr - current_cfr)

        incident_cost_savings = prevented_failures * self.costs['average_incident_cost']
        productivity_savings = prevented_failures * 8 * self.costs['engineer_hourly_rate']
        downtime_savings = prevented_failures * 0.5 * self.costs['downtime_cost_per_hour']

        total_savings = incident_cost_savings + productivity_savings + downtime_savings
        roi = (total_savings - self.infrastructure_cost) / self.infrastructure_cost

        return {
            'prevented_incidents': prevented_failures,
            'incident_cost_savings': incident_cost_savings,
            'productivity_savings': productivity_savings,
            'downtime_savings': downtime_savings,
            'total_monthly_savings': total_savings,
            'roi': roi
        }

# Prefect Tasks
@task(log_prints=True)
def ingest_data_task(topic: str) -> List[Dict[str, Any]]:
    pipeline = AIOpsPipeline()
    records = pipeline.ingest_data(topic=topic, timeout=10, max_records=50)
    pipeline.close()
    return records or []

@task(log_prints=True)
def feature_engineering_task(raw_data: Dict[str, Any]) -> pd.DataFrame:
    fe = FeatureEngineering()
    return fe.create_deployment_features(raw_data=raw_data)

@task(log_prints=True)
def model_inference_task(raw_data: Dict[str, Any], classifier, scaler) -> Dict[str, Any]:
    logger = get_run_logger()
    inference = RealTimeInference(classifier, scaler)
    return inference.predict_with_explanation(deployment_data=raw_data)

@task(log_prints=True)
def dashboard_task(metrics_data: Dict[str, Any]) -> Dict[str, Any]:
    dashboard = AIOpsDashboard()
    return dashboard.generate_dashboard_data(metrics_data)


@task(log_prints=True)
def run_jenkins_plugin_task(predictor, build_data: Dict[str, Any]) -> Any:
    cicd = CICDIntegration(predictor)
    return cicd.jenkins_plugin(build_data)

@task(log_prints=True)
def ci_task(prediction: Dict[str, Any], raw_data: Dict[str, Any]) -> Any:
    from src.continuous_improvement import ContinuousImprovement
    ci = ContinuousImprovement()
    actual_outcome = raw_data.get('failure_label', False)
    ci.collect_feedback(prediction, actual_outcome)
    return ci.analyze_performance()

# ROI instance
roi_calculator = ROICalculator()

# -------------------------
# Main Prefect Flow
# -------------------------
@flow(name="Change Failure Prediction Pipeline with ROI", log_prints=True)
def main_flow() -> Dict[str, Any]:
    logger = get_run_logger()

    if not RF_MODEL_PATH.exists() or not SCALER_PATH.exists():
        logger.error("Model files missing.")
        return {"status": "Model files missing"}

    # Load models once
    classifier = joblib.load(RF_MODEL_PATH)
    scaler = joblib.load(SCALER_PATH)
    predictor = RealTimeInference(classifier, scaler)

    ingested_records = ingest_data_task(topic='deployment-metrics')
    if not ingested_records:
        logger.info("No new data")
        return {"status": "No new data"}

    results = []
    baseline_cfr = 0.3
    current_cfr = 0.1
    deployments_per_month = 100
    total_prevented_failures = 0
    prediction_correct_count = 0
    active_deployments_count = 0

    for record in ingested_records:
        raw_data = record.get('data')
        if not raw_data:
            logger.warning("Skipping empty record")
            continue

        logger.info(f"Processing deployment: {raw_data.get('deployment_id')}")
        active_deployments_count += 1

        features_df = feature_engineering_task(raw_data=raw_data)
        prediction = model_inference_task(raw_data=raw_data, classifier=classifier, scaler=scaler)

        prevented_failures = prediction.get('prevented_failures', 0)
        total_prevented_failures += prevented_failures

        if prediction.get('prediction_correct') is True:
            prediction_correct_count += 1

        if active_deployments_count > 0:
            system_health = 'GOOD' if prediction_correct_count >= 0.8 * active_deployments_count else 'WARNING'
        else:
            system_health = 'GOOD'

        # Real-time metrics to match Grafana JSON
        real_time_metrics = {
            'change_failure_rate_change_percentage': ((baseline_cfr - current_cfr) / baseline_cfr) * 100,
            'model_accuracy_percentage': 98.5,
            'estimated_annual_savings_usd': 123456.78,
            'prevented_incidents_total': total_prevented_failures,
            'mttr_reduction_percentage': 12.3,
            'ml_pipeline_status': 1,
            'active_deployments_count': active_deployments_count,
            'average_risk_score_percentage': raw_data.get('risk_score', 20),
            'current_test_coverage_percentage': 85.0,
            'build_success_rate_percentage': 99.1,
            'current_overall_risk_score': raw_data.get('risk_score', 20),
            'overall_risk_score': raw_data.get('risk_score', 20),
            'your_deployment_metric': {
                'ANALYZE': 1
            }
        }

        dashboard_data = dashboard_task(real_time_metrics)
        cicd_result = run_jenkins_plugin_task(predictor, raw_data)
        performance = ci_task(prediction=prediction, raw_data=raw_data)

        results.append({
            'raw_data': raw_data,
            'features': features_df,
            'prediction': prediction,
            'dashboard': dashboard_data,
            'cicd': cicd_result,
            'performance': performance
        })

    savings = roi_calculator.calculate_savings(
        baseline_cfr, current_cfr, deployments_per_month, actual_prevented_failures=total_prevented_failures
    )
    logger.info(f"ROI Calculation: {savings}")
    logger.info(f"âœ… Processed {len(results)} deployment(s)")

    return {"results": results, "roi": savings}

if __name__ == "__main__":
    main_flow()
